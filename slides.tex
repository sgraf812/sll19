\documentclass{haskellbeamer}

\title{Selective Lambda Lifting}
\date{24 June 2019}

\bibliography{bibliography.bib}
\input{defs.tex}

% Syntax
\newcommand{\keyword}[1]{\textsf{\textbf{#1}}}
\newcommand{\id}[1]{\textsf{\textsl{#1}}\xspace}
\newcommand{\idx}{\id{x}}
\newcommand{\idy}{\id{y}}
\newcommand{\idz}{\id{z}}
\newcommand{\idbs}{\id{bs}}
\newcommand{\idlbs}{\id{lbs}}
\newcommand{\ide}{\id{e}}
\newcommand{\idf}{\id{f}}
\newcommand{\idg}{\id{g}}
\newcommand{\idm}{\id{m}}
\newcommand{\idr}{\id{r}}
\newcommand{\closure}[1]{[\mskip1.5mu #1 \mskip1.5mu]}
\newcommand{\mkRhs}[2]{\lambda #1 \to #2}
\newcommand{\mkBind}[2]{#1 \mathrel{=} #2}
\newcommand{\mkBindr}[2]{\overline{\mkBind{#1}{#2}}}
\newcommand{\mkLetb}[2]{\keyword{let}\; #1\; \keyword{in}\; #2}
\newcommand{\mkLet}[4]{\mkLetb{\mkBind{#1}{\mkRhs{#2}{#3}}}{#4}}
\newcommand{\mkLetr}[4]{\mkLetb{\mkBindr{#1}{\mkRhs{#2}{#3}}}{#4}}
\newcommand{\sfop}[1]{\textsf{#1}\xspace}
\newcommand{\fun}[1]{\textsf{#1}\xspace}
\newcommand{\ty}[1]{\textsf{#1}\xspace}
\newcommand{\idiom}[1]{\left\llbracket#1\right\rrbracket}
\newcommand{\writer}[2]{\mathcal{W}_#1\,#2}
\newcommand{\eff}[1]{\left\langle#1\right\rangle}
\newcommand{\lift}{\fun{lift}}
\newcommand{\liftv}{\fun{lift-var}}
\newcommand{\liftb}{\fun{lift-bind}}
\newcommand{\abs}{\fun{abstract}}
\newcommand{\addrqs}{\fun{add-rqs}}
\newcommand{\expand}{\fun{expand}}
\newcommand{\decide}{\fun{decide-lift}}
\newcommand{\recurse}{\fun{recurse}}
\newcommand{\note}{\fun{note}}
\newcommand{\fvs}{\fun{fvs}}
\newcommand{\rqs}{\fun{rqs}}
\newcommand{\expander}{\ty{Expander}}
\newcommand{\var}{\ty{Var}}
\newcommand{\expr}{\ty{Expr}}
\newcommand{\bindgr}{\ty{Bind}}
\newcommand{\rhs}{\ty{Rhs}}
\newcommand{\prog}{\ty{Prog}}
\newcommand{\emptybind}{\varepsilon}
\newcommand{\wrap}{\fun{wrap}}
\newcommand{\dom}[1]{\sfop{dom}\,#1}
\newcommand{\absids}{\alpha}
\newcommand{\added}{\varphi^+}
\newcommand{\removed}{\varphi^-}
\newcommand{\cg}{\fun{cl-gr}}
\newcommand{\cgb}{\fun{cl-gr-bind}}
\newcommand{\cgr}{\fun{cl-gr-rhs}}
\newcommand{\growth}{\fun{growth}}
\newcommand{\local}{\fun{local}}
\newcommand{\zinf}{\mathbb{Z}_{\infty}}
\newcommand{\card}[1]{\left\vert#1\right\vert}


\begin{document}

\maketitle

\begin{frame}[fragile]{Motivation}
  \begin{center}
    \begin{minipage}{0.7\textwidth}
      \begin{overprint}
        \onslide<1>
        \begin{haskell}
          f a 0 = a
          f a n = f (g (n `mod` 2)) (n-1)
            where
              g 0 = a
              g n = 1 + g (n-1)
        \end{haskell}
        \onslide<2>
        \begin{haskell}
          f a 0 = a
          f a n = f (g' a (n `mod` 2)) (n-1)

          g' a 0 = a
          g' a n = 1 + g' a (n-1)
        \end{haskell}
        \onslide<3>
        \begin{haskell}
f :: [Int] -> [Int] -> Int -> Int
f a b 0 = a
f a b 1 = b
f a b n = f (g n) a (n `mod` 2)
  where
    g 0 = a
    g 1 = b
    g n = n : h
      where
        h = g (n-1)
        \end{haskell}
        \onslide<4>
        \begin{haskell}
f :: [Int] -> [Int] -> Int -> Int
f a b 0 = a
f a b 1 = b
f a b n = f (g' a b n) a (n `mod` 2)

g' a b 0 = a
g' a b 1 = b
g' a b n = n : h
  where
    h = g' a b (n-1)
        \end{haskell}

      \end{overprint}
    \end{minipage}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Closure Conversion vs. Lambda Lifting}
  \begin{itemize}
    \item Codegen strategies: turn local functions into global functions and auxiliary heap allocations
    \item Closure Conversion: References to free variables lowered as fields accesses on a closure record containing all FVs
    \item Lambda Lifting: Convert free variables into parameters, supplied as additional arguments at call sites
  \end{itemize}
  \begin{center}
    \begin{overprint}
      \begin{minipage}{0.45\textwidth}
        \begin{haskell}
          let f = \a b -> a*x+b*y
          in f 4 2
        \end{haskell}
      \end{minipage}%
      \begin{minipage}{0.1\textwidth}
        $\xRightarrow{\text{\only<1>{CC}\only<2>{LL} }\idf}$
      \end{minipage}%
      \onslide<1>
      \begin{minipage}{0.45\textwidth}
        \begin{haskell}
          data EnvF = EnvF
            { x :: Int
            , y :: Int }
          f' env a b =
            a*x env + b*y env;
          let f = (f', EnvF x y)
          in (fst f) (snd f) 4 2
        \end{haskell}
      \end{minipage}
      \onslide<2>
      \begin{minipage}{0.45\textwidth}
        \begin{haskell*}{stripnl=false}
          


          f' x y a b = a*x + b*y;
          f' x y 4 2
        \end{haskell*}
      \end{minipage}
    \end{overprint}
  \end{center}
\end{frame}

\begin{frame}[fragile]{When to lift?}
  \begin{center}
    \begin{minipage}{0.45\textwidth}
      \onslide<2->
      When \emph{not} to lift?
      \begin{itemize}
        \item<3-> Argument occurrences
        \item<6-> Closure growth
        \item<8-> Calling convention
        \item<10-> Known calls to FVs
        \item<12-> Sharing
      \end{itemize}
    \end{minipage}%
    \begin{minipage}{0.55\textwidth}
      \begin{overprint}
        \onslide<3-5>
        \begin{haskell}
          let f = \a b c -> a*x + b*y + z
          in g 5 x f
        \end{haskell}
        \onslide<6-7>
        \begin{haskell}
          let f = \a b -> a*x + b*y
              g = \d -> f d d + x
          in g 5
        \end{haskell}
        \onslide<8-9>
        \begin{haskell}
          let f = \a b c d -> a*b*c*d*x*y*z
          in f 1 2 3 4
        \end{haskell}
        \onslide<10-11>
        \begin{haskell}
          let f = \x -> 2*x
              mapF = \xs -> case xs of
                []    -> []
                x:xs' -> f x : mapF xs'
          in mapF [1..n]
        \end{haskell}
        \onslide<12-13>
        \begin{haskell}
          let p = (,) x y
          in fst p + snd p
        \end{haskell}
      \end{overprint}
      \begin{overprint}
        \onslide<4>
        \hspace{0.4\textwidth}$\Big\Downarrow$ LL $\idf$
        \begin{haskell}
          f' a b c = a*x + b*y + z;
          g 5 x (f' x y)
        \end{haskell}
        \onslide<5>
        \hspace{0.4\textwidth}$\Big\Downarrow$ LL $\idf$
        \begin{haskell}
          f' a b c = a*x + b*y + z;
          let f = f' x y
          in g 5 x f
        \end{haskell}
        \onslide<7>
        \hspace{0.4\textwidth}$\Big\Downarrow$ LL $\idf$
        \begin{haskell}
          f' x y a b = a*x + b*y;
          let g = \d -> f x y d d + x
          in g 5
        \end{haskell}
        \onslide<9>
        \hspace{0.4\textwidth}$\Big\Downarrow$ LL $\idf$
        \begin{haskell}
          f' a b c d = a*b*c*d*x*y*z;
          in f' x y z 1 2 3 4
        \end{haskell}
        \onslide<11>
        \hspace{0.4\textwidth}$\Big\Downarrow$ LL $\id{mapF}$
        \begin{haskell}
          mapF []      = [];
          mapF (x:xs') = f' x : mapF xs';
          let f = \x -> 2*x
          in mapF' f [1..n]
        \end{haskell}
        \onslide<13>
        \hspace{0.4\textwidth}$\Big\Downarrow$ LL $\id{p}$
        \begin{haskell}
          p x y = (,) x y
          fst (p x y) + snd (p x y)
        \end{haskell}
      \end{overprint}
    \end{minipage}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Estimating Closure Growth}
  \begin{center}
    \begin{minipage}{0.45\textwidth}
      \begin{itemize}
        \item<3-> Closure alloc minus syntactic call sites? \only<5->{\xmark}
        \item<6-> Don't lift multi-shot occurrences? \only<7->{\xmark}
        \item<6->  \only<7->{\xmark}
      \end{itemize}
    \end{minipage}%
    \begin{minipage}{0.55\textwidth}
      \begin{overprint}
        \onslide<2-3>
        \begin{haskell}
          let f = \a b -> a*x + b*y
              g = \d -> f d d + x
          in g 5
        \end{haskell}
        \hspace{0.4\textwidth}$\Big\Downarrow$ LL $\idf$
        \begin{haskell}
          f' x y a b = a*x + b*y;
          let g = \d -> f x y d d + x
          in g 5
        \end{haskell}
        \onslide<4-6>
        \begin{haskell}
          let f = \a b -> a*x + b*y
              g = \d ->
                let h = \e -> f e e
                in h x
          in g 1 + g 2 + g 3
        \end{haskell}
        \hspace{0.4\textwidth}$\Big\Downarrow$ LL $\idf$
        \begin{haskell}
          f' x y a b = a*x + b*y;
          let g = \d ->
                let h = \e -> f' x y e e
                in h x
          in g 1 + g 2 + g 3
        \end{haskell}
        \onslide<7->
        \begin{haskell}
          let f = \a b -> a*x + b*y
              g = \d ->
                let h = \e -> f e e
                in h x
          in g 1 + g 2 + g 3
        \end{haskell}
        \hspace{0.4\textwidth}$\Big\Downarrow$ LL $\idf$
        \begin{haskell}
          f' x y a b = a*x + b*y;
          let g = \d ->
                let h = \e -> f' x y e e
                in h x
          in g 1 + g 2 + g 3
        \end{haskell}
      \end{overprint}
    \end{minipage}
  \end{center}
\end{frame}

%\begin{frame}[fragile]{Strictness Analysis}
%  \begin{itemize}
%    \item Provides lower bounds on \emph{evaluation cardinality}
%    \item Is this variable evaluated at least once?
%      \begin{itemize}
%        \item \emph{Strictness}: $\sStr \Coloneqq S \mid L$
%        \item $S$trict (Yes!)
%        \item $L$azy (Not sure)
%      \end{itemize}
%    \item Enables call-by-value, unboxing
%  \end{itemize}
%  \begin{center}
%    \begin{minipage}{0.7\textwidth}
%      \begin{overprint}
%        \onslide<1>
%        \begin{haskell}
%          main = do
%            let  x = ... -- $S$
%            let  y = ... -- $S$
%            let  z = ... -- $L$
%            print (x + if odd y then y else z)
%        \end{haskell}
%        \onslide<2>
%        \begin{haskell}
%          main = do
%            let !x = ... -- $S$
%            let !y = ... -- $S$
%            let  z = ... -- $L$
%            print (x + if odd y then y else z)
%        \end{haskell}
%      \end{overprint}
%    \end{minipage}
%  \end{center}
%\end{frame}
%
%\begin{frame}[fragile]{GHC's Demand Analyser}
%  \begin{itemize}
%    \item Performs strictness analysis (among other things)
%    \item Fuels Worker/Wrapper transformation
%    \item Backward analysis
%      \begin{itemize}
%        \item Which strictness does an expression place on its free variables?
%        \item Which strictness does a function place on its arguments?
%      \end{itemize}
%    \item \emph{Strictness type}: $\sStrType = \lPair{\sFVs \pfun \sStr}{\sStr^*}$
%  \end{itemize}
%\end{frame}
%
%\begin{frame}[fragile]{Strictness Signatures}
%  \begin{itemize}
%    \item Looks at the right-hand side of \hs{const} before the \hs{let} body!
%    \item \emph{Unleashes} strictness type of \hs{const}'s RHS at call sites
%  \end{itemize}
%  \begin{center}
%    \begin{minipage}{0.8\textwidth}
%      \begin{haskell*}{escapeinside=||}
%        let const a b = a -- $\mathtt{const} :: \lPair{\emptymap}{[S, L]}$
%        in const 
%            y            -- $S$
%            (error |\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\includegraphics[width=3.85mm]{bomb.png}}\PYG{l+s}{\PYGZdq{}}|) -- $L$
%      \end{haskell*}
%    \end{minipage}
%  \end{center}
%\end{frame}
%
%\begin{frame}[fragile]{Call Context Matters}
%  \begin{overprint}
%    \onslide<1-3>
%    \begin{itemize}
%      \item Whole expression is strict in \hs{z}
%      \item Only digests \hs{f} for manifest arity 1, can't look under lambda
%      \item \hs{f} is called with 2 arguments
%      \item<4>[\ding{213}] Analyse bound function when incoming arity is known
%    \end{itemize}
%    \onslide<4->
%    \begin{itemize}
%      \item Solution: Analyse RHS when incoming arity is known
%      \item Formally: Finite approximation of \emph{strictness transformer}
%        \begin{itemize}
%          \item $\sStrTrans = \mathbb{N} \to \sStrType$
%        \end{itemize}
%      \item Exploit laziness to memoise results?
%    \end{itemize}
%  \end{overprint}
%  \begin{overprint}
%    \onslide<1>
%    \begin{center}
%      \begin{minipage}{0.7\textwidth}
%        \begin{haskell*}{escapeinside=||}
%          let f x = -- $\mathtt{f} :: \lPair{\maplit{\mathtt{z}}{L}}{[S]}$
%                if odd x
%                  then \y -> y*|\color{red}\texttt{z}|
%                  else \y -> y+|\color{red}\texttt{z}|
%          in f 1 2
%        \end{haskell*}
%      \end{minipage}
%    \end{center}
%    \onslide<2>
%    \begin{center}
%      \begin{minipage}{0.7\textwidth}
%        \begin{haskell*}{escapeinside=||}
%          let f x = -- $\mathtt{f} :: \lPair{\maplit{\mathtt{z}}{L}}{[S]}$
%                if odd x
%                  then \y -> y*z
%                  else \y -> y+z
%          in seq (f 1) 42
%        \end{haskell*}
%      \end{minipage}
%    \end{center}
%    \onslide<3>
%    \begin{center}
%      \begin{minipage}{0.7\textwidth}
%        \begin{haskell*}{escapeinside=||}
%          let f x = -- $\mathtt{f} :: \lPair{\maplit{\mathtt{z}}{L}}{[S]}$
%                if odd x
%                  then \y -> y*z
%                  else \y -> y+z
%          in f 1 2
%        \end{haskell*}
%      \end{minipage}
%    \end{center}
%    \onslide<4>
%    \begin{center}
%      \begin{minipage}{0.7\textwidth}
%        \begin{haskell*}{escapeinside=||}
%          let f x = -- $\mathtt{f}_{\color{red}1} :: \lPair{\maplit{\mathtt{z}}{L}}{[S]}$
%                if odd x
%                  then \y -> y*z
%                  else \y -> y+z
%          in f 1 2
%        \end{haskell*}
%      \end{minipage}
%    \end{center}
%    \onslide<5>
%    \begin{center}
%      \begin{minipage}{0.7\textwidth}
%        \begin{haskell*}{escapeinside=||}
%          let f x = -- $\mathtt{f}_{\color{red}2} :: \lPair{\maplit{\mathtt{z}}{S}}{[S,S]}$
%                if odd x
%                  then \y -> y*z
%                  else \y -> y+z
%          in f 1 2
%        \end{haskell*}
%      \end{minipage}
%    \end{center}
%  \end{overprint}
%\end{frame}
%  
%\begin{frame}[fragile]{Recursion}
%  \begin{itemize}
%    \item Exploit laziness to memoise approximations?
%    \item[\xmark] Recursion leads to termination problems
%    \item Rediscovered fixed-point iteration, detached from the syntax tree
%    \item Leads to data-flow problem, solved by worklist algorithm
%  \end{itemize}
%  \begin{center}
%    \begin{minipage}{0.5\textwidth}
%      \begin{haskell}
%        let fac n = 
%              if n == 0
%                then 1
%                else n * fac (n-1)
%        in fac 12
%      \end{haskell}
%    \end{minipage}
%  \end{center}
%\end{frame}
%
%\begin{frame}[fragile]{Data-flow Graph for Strictness Analysis}
%  \begin{itemize}
%    \item Allocate nodes to break recursion
%      \begin{itemize}
%        \item One top-level node
%        \item One node per pair of $(\text{\hs{let} binding}, \text{incoming arity})$
%      \end{itemize}
%    \item Initialise worklist to top-level node
%    \item Initialise nodes with $\bot$
%  \end{itemize}
%  \begin{overprint}
%    \begin{columns}
%      \begin{column}{0.35\textwidth}
%        \begin{haskell}
%          let f 0 = const 0
%              f 1 = id 
%              f n = f (n `mod` 2)
%          in f x y
%        \end{haskell}
%      \end{column}
%      \begin{column}{0.02\textwidth}
%        {\Huge$\Rightarrow$}
%      \end{column}
%      \begin{column}{0.4\textwidth}
%        \begin{tikzpicture}[->, thick]
%          \useasboundingbox (-1,-1.5) rectangle (4,1.5);
%          \node[n] at (0,0) (root) 
%            [label={[visible on=<4>]above:$\bot$}]
%            {$\dfnode{<root>}{0}$};
%          \foreach \i in {-0.05,0,0.05} {
%            \node[n, visible on=<2->] at (3,0) (fx) 
%              [xshift=\i cm, yshift=-\i cm] {$\dfnode{f}{n}$};
%          }
%          \node[visible on=<4>] at ([shift={(90:1.1)}]fx) {$\bot$};
%        \end{tikzpicture}
%      \end{column}
%    \end{columns}
%    \onslide<3->
%    \begin{columns}
%      \begin{column}{0.55\textwidth}
%        \hfill Worklist:
%      \end{column}
%      \begin{column}{0.55\textwidth}
%        $\{\dfnode{<root>}{0}\}$ \hfill
%      \end{column}
%    \end{columns}
%  \end{overprint}
%\end{frame}
%
%\begin{frame}[fragile]{Data-flow Graph for Strictness Analysis}
%  \begin{overprint}
%    \begin{columns}
%      \begin{column}{0.35\textwidth}
%        \begin{haskell}
%          let f 0 = const 0
%              f 1 = id 
%              f n = f (n `mod` 2)
%          in f x y
%        \end{haskell}
%      \end{column}
%      \begin{column}{0.02\textwidth}
%        {\Huge$\Rightarrow$}
%      \end{column}
%      \begin{column}{0.4\textwidth}
%        \begin{tikzpicture}[->, thick]
%          \useasboundingbox (-1,-2) rectangle (4,2);
%          \node[n] at (0,0) (root) [hl={<2-8>}] 
%            [label={[visible on=<-7>]above:$\bot$},
%             label={[visible on=<8->]above:$\lPair{\alert<8,13>{\left[\mathtt{x} \mapsto S, \mathtt{y} \mapsto L\right]}}{[]}$}]
%            {$\dfnode{<root>}{0}$};
%          \foreach \i in {-0.05,0,0.05} {
%            \node<-2>[n] at (3,0) (fx) [xshift=\i cm, yshift=-\i cm] {$\dfnode{f}{n}$};
%          }
%          \draw<3-> (root) edge [hl={<3,7>}] (f2);
%          \node[n, visible on=<3->, hl={<3-7,10-12>}] 
%            at (3,0) (f2) 
%            [label={[visible on=<-4>]above:$\bot$},
%             label={[visible on=<5-6>]above:$\bot=\lPair{\emptymap}{[S,S]}$},
%             label={[visible on=<7->]above:$\lPair{\emptymap}{[S,\alert<7>{L}]}$}]
%            {$\dfnode{f}{2}$};
%          \draw<4-> (f2) edge [loop, in=-110, out=-70, looseness=5, hl={<4-6,11>}] (f2);
%        \end{tikzpicture}
%      \end{column}
%    \end{columns}
%    \begin{columns}
%      \begin{column}{0.55\textwidth}
%        \hfill Worklist:
%      \end{column}
%      \begin{column}{0.55\textwidth}
%        \only<1>{$\{\alert{\dfnode{<root>}{0}}\}$}\only<2-5>{$\{\}$}\only<6-9>{$\{\alert<6,9>{\dfnode{f}{2}}\}$}\only<10->{$\{\}$}
%      \end{column}
%    \end{columns}
%  \end{overprint}
%\end{frame}
%
%\begin{frame}[fragile]{Implementation}
%  \begin{itemize}
%    \item Hide iteration strategy behind \hs{TransferFunction} monad
%    \item Data-flow nodes \hs{k}, denoting lattice \hs{v}
%    \item Single `impure' primitive \hs{dependOn}
%  \end{itemize}
%  \begin{center}
%    \begin{minipage}{0.9\textwidth}
%      \begin{haskell}
%        data TransferFunction k v a
%        instance Monad (TransferFunction k v)
%
%        dependOn
%          :: Ord k
%          => k
%          -> TransferFunction k v (Maybe v)
%      \end{haskell}
%    \end{minipage}
%  \end{center}
%\end{frame}
%
%\begin{frame}[fragile]{Implementation}
%  \begin{itemize}
%    \item \hs{DataFlowProblem} assigns \hs{TransferFunction} and \hs{ChangeDetector} to nodes
%  \end{itemize}
%  \begin{center}
%    \begin{minipage}{0.9\textwidth}
%      \begin{haskell}
%        type ChangeDetector k v
%          = v -> v -> Bool
%
%        data DataFlowProblem k v 
%          = DFP 
%          { transfer      :: k -> TransferFunction k v v
%          , detectChanges :: k -> ChangeDetector k v
%          }
%      \end{haskell}
%    \end{minipage}
%  \end{center}
%\end{frame}
%
%\begin{frame}[fragile]{Implementation}
%  \begin{itemize}
%    \item \hs{fixProblem} solves data-flow problems 
%    \item Specification as \hs{DataFlowProblem}
%    \item Implements fixed-point iteration strategy
%      \begin{itemize}
%        \item Can use worklist algorithm, starting from a specified root set
%      \end{itemize}
%  \end{itemize}
%  \begin{center}
%    \begin{minipage}{0.5\textwidth}
%      \begin{haskell}
%        fixProblem
%          :: Ord k
%          => DataFlowProblem k v
%          -> Set k
%          -> Map k v
%      \end{haskell}
%    \end{minipage}
%  \end{center}
%\end{frame}
%
%\begin{frame}[fragile]{Applied to Strictness Analysis}
%  \begin{itemize}
%    \item Denote expressions by their strictness transformer
%    \item Model points of strictness transformer separately
%    \item Instantiate as \hs{DataFlowProblem (ExprNode, Arity) StrType}
%    \item \hs{ExprNode}: Totally ordered, allocated as needed
%      \begin{itemize}
%        \item Dictates priority in worklist
%        \item Performance depends on suitable priorities
%      \end{itemize}
%  \end{itemize}
%\end{frame}
%
%\begin{frame}{Comparison to \texttt{hoopl}}
%  \begin{itemize}
%    \item \texttt{hoopl} \parencite{hoopl} works on CFGs
%      \begin{itemize}
%        \item Data-flow Graph
%        \item Basic blocks vs. transfer functions
%        \item Edges implicit in DSL 
%      \end{itemize}
%    \item Imperative languages vs. declarative languages
%    \item `Operational' rather than `denotational'
%      \begin{itemize}
%        \item Small-step vs. compositional
%      \end{itemize}
%    \item Makes (join-semi)lattice explicit
%      \begin{itemize}
%        \item TODO
%      \end{itemize}
%    \item Also includes a solution for transformations
%  \end{itemize}
%\end{frame}
%
%\begin{frame}{Discussion}
%  \begin{itemize}
%    \item[\cmark] Decouple analysis logic from iteration logic by a graph-based approach
%    \item[\xmark] Coupling not as painful as it would be in imperative programs
%    \item[\cmark] Still obscures intent, even obstructs ideas
%    \item[\cmark] `Hacks' such as caching of analysis results as in \textcite[ยง9.2]{dmd} between iterations for free
%    \item[\xmark] Unclear how performance is affected
%    \item[\xmark] Can only shine if shared concerns are actually extracted from a number of analyses
%  \end{itemize}
%\end{frame}
%
%\begin{frame}{Conclusion}
%  \begin{itemize}
%    \item Pitched an interesting idea that came out of my thesis
%    \item Separate \emph{specification} of data-flow problems from computing its \emph{solution}
%    \item Unobtrusive monadic DSL
%    \item Future Work:
%      \begin{enumerate}
%        \item (Monotone) maps with partially-ordered keys\footnote{\tiny\url{https://github.com/sgraf812/pomaps/}}
%        \item Polish API, make a package\footnote{\tiny\url{https://github.com/sgraf812/datafix}}
%        \item Testdrive and measure it in GHC
%      \end{enumerate}
%  \end{itemize}
%\end{frame}
%
%\begin{frame}{Done}
%  \begin{columns}
%    \begin{column}{0.4\textwidth}
%      \begin{center}
%        \includegraphics[width=\textwidth]{qr_slides.jpg}
%        \\
%        \href{https://rawgit.com/sgraf812/hiw17/master/slides.pdf}{Slides}
%      \end{center}
%    \end{column}
%    \begin{column}{0.4\textwidth}
%      \begin{center}
%        \includegraphics[width=\textwidth]{qr_usage.jpg}
%        \\
%        \href{https://github.com/sgraf812/ghc/blob/6f9f06c2d1bf3a9168ec4079ebf6da26398e54b9/compiler/simplCore/UsageAnal/Analysis.hs#L252}{Real-world example}
%      \end{center}
%    \end{column}
%  \end{columns}
%\end{frame}
%
%\begin{frame}{Bibliography} 
%  \printbibliography[heading=none]
%\end{frame}
%
%\section{Backup}
%
%\begin{frame}[fragile]{Example}
%  \begin{overprint}
%    \begin{columns}
%      \begin{column}{0.4\textwidth}
%        \begin{overprint}
%          \onslide<1>
%          \begin{haskell}
%            let f 0 = const 0
%                f 1 = id 
%                f n = 
%                  const (f (n `mod` 2) 4)
%            in f x y
%          \end{haskell}
%          \onslide<2->
%          \begin{haskell}
%            let f 0 = const 0
%                f 1 = id 
%                f n = 
%                  const (f (n `mod` 2) 4)
%            in seq (f x) (f x y)
%          \end{haskell}
%        \end{overprint}
%      \end{column}
%      \begin{column}{0.02\textwidth}
%        {\Huge$\Rightarrow$}
%      \end{column}
%      \begin{column}{0.4\textwidth}
%        \begin{tikzpicture}[->, thick]
%          \useasboundingbox (-1,-2) rectangle (4,2);
%          \node[n] at (0,0) (root) {$\dfnode{<root>}{0}$};
%          \foreach \i in {-0.05,0,0.05} {
%            \node<-2>[n] at (3,0) (fx) [xshift=\i cm, yshift=-\i cm] {$\dfnode{f}{n}$};
%          }
%          \node[n, visible on=<3->] at (3,1.5) (f1) {$\dfnode{f}{1}$};
%          \node[n, visible on=<3->] at (3,-1.5) (f2) {$\dfnode{f}{2}$};
%          \draw<3-> 
%            (root) edge [bend left] (f1)
%            (root) edge [bend right] (f2)
%            (f1) edge [bend left] (f2)
%            (f2) edge [loop, in=-80, out=-40, looseness=5] (f2);
%        \end{tikzpicture}
%      \end{column}
%    \end{columns}
%  \end{overprint}
%\end{frame}
%
%\begin{frame}[fragile]{Implementation: Behind the Curtain}
%  \begin{itemize}
%    \item \hs{TransferFunction} is a \hs{State} monad around \hs{WorklistState}
%  \end{itemize}
%  \begin{center}
%    \begin{minipage}{0.8\textwidth}
%      \begin{haskell}
%        data TransferFunction node lattice a
%          = TFM (State (WorklistState node lattice ) a)
%          deriving (Functor, Applicative, Monad)
%      \end{haskell}
%    \end{minipage}
%  \end{center}
%\end{frame}
%
%\begin{frame}[fragile]{Threading annotated expressions}
%  \begin{itemize}
%    \item Annotated \hs{CoreExpr}s are the reason why we do this!
%    \item Thread it through all nodes: \hs{DataFlowProblem (ExprNode, Arity) (StrType, CoreExpr)}
%    \item Complicates change detection
%      \begin{itemize}
%        \item Expressions follow AST structure
%        \item Possibly change when strictness type did not
%        \item \hs{ChangeDetector} has to check set of changed dependencies
%      \end{itemize}
%    \item $\sStr \Coloneqq S \mid L$ not enough for annotating functions
%      \begin{itemize}
%        \item $\sStr \Coloneqq S^n \mid L$ with arity $n\in \mathbb{N}$
%        \item `\hs{f} was called at least once, with at least $n$ arguments'
%      \end{itemize}
%    \item ... Or do it as the Demand Analyser does: Assume manifest arity for annotation
%      \begin{itemize}
%        \item Be careful not to inline unsaturated wrappers!
%      \end{itemize}
%  \end{itemize}
%\end{frame}
%
%\begin{frame}[fragile]{Caching of Analysis Results due to Henglein}
%  \begin{center}
%    \begin{minipage}{0.8\textwidth}
%      \begin{haskell}
%        let f x =
%              let g y = 
%                    if odd y 
%                      then g (y - 1) 
%                      else x
%              in if even x 
%                  then g x 
%                  else f (3*x + 1)
%        in f 7
%      \end{haskell}
%    \end{minipage}
%  \end{center}
%\end{frame}

\begin{frame}[fragile]{Example that slows down by 10\%}
  \begin{center}
    \begin{minipage}{0.7\textwidth}
      \begin{overprint}
      \end{overprint}
    \end{minipage}
  \end{center}
\end{frame}


\end{document}
